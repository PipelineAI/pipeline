# Generated by the protocol buffer compiler.  DO NOT EDIT!
# source: tensorflow/core/protobuf/master_service.proto

import sys
_b=sys.version_info[0]<3 and (lambda x:x) or (lambda x:x.encode('latin1'))
from google.protobuf import descriptor as _descriptor
from google.protobuf import message as _message
from google.protobuf import reflection as _reflection
from google.protobuf import symbol_database as _symbol_database
from google.protobuf import descriptor_pb2
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()


from tensorflow.core.protobuf import master_pb2 as tensorflow_dot_core_dot_protobuf_dot_master__pb2


DESCRIPTOR = _descriptor.FileDescriptor(
  name='tensorflow/core/protobuf/master_service.proto',
  package='tensorflow.grpc',
  syntax='proto3',
  serialized_pb=_b('\n-tensorflow/core/protobuf/master_service.proto\x12\x0ftensorflow.grpc\x1a%tensorflow/core/protobuf/master.proto2\xbc\x04\n\rMasterService\x12T\n\rCreateSession\x12 .tensorflow.CreateSessionRequest\x1a!.tensorflow.CreateSessionResponse\x12T\n\rExtendSession\x12 .tensorflow.ExtendSessionRequest\x1a!.tensorflow.ExtendSessionResponse\x12Z\n\x0fPartialRunSetup\x12\".tensorflow.PartialRunSetupRequest\x1a#.tensorflow.PartialRunSetupResponse\x12\x42\n\x07RunStep\x12\x1a.tensorflow.RunStepRequest\x1a\x1b.tensorflow.RunStepResponse\x12Q\n\x0c\x43loseSession\x12\x1f.tensorflow.CloseSessionRequest\x1a .tensorflow.CloseSessionResponse\x12N\n\x0bListDevices\x12\x1e.tensorflow.ListDevicesRequest\x1a\x1f.tensorflow.ListDevicesResponse\x12<\n\x05Reset\x12\x18.tensorflow.ResetRequest\x1a\x19.tensorflow.ResetResponseB3\n\x1aorg.tensorflow.distruntimeB\x13MasterServiceProtosP\x01\x62\x06proto3')
  ,
  dependencies=[tensorflow_dot_core_dot_protobuf_dot_master__pb2.DESCRIPTOR,])



_sym_db.RegisterFileDescriptor(DESCRIPTOR)


DESCRIPTOR.has_options = True
DESCRIPTOR._options = _descriptor._ParseOptions(descriptor_pb2.FileOptions(), _b('\n\032org.tensorflow.distruntimeB\023MasterServiceProtosP\001'))
try:
  # THESE ELEMENTS WILL BE DEPRECATED.
  # Please use the generated *_pb2_grpc.py files instead.
  import grpc
  from grpc.beta import implementations as beta_implementations
  from grpc.beta import interfaces as beta_interfaces
  from grpc.framework.common import cardinality
  from grpc.framework.interfaces.face import utilities as face_utilities


  class MasterServiceStub(object):
    """//////////////////////////////////////////////////////////////////////////////

    MasterService defines a TensorFlow service with which a client can
    interact to execute a distributed TensorFlow computation.

    A master service keeps track of multiple "master sessions". Each
    session encapsulates a computation graph and its associated state,
    and typically corresponds to a single "client session" (e.g. a
    `tensorflow::Session` instance).

    A session is responsible for the following:
    * assigning each node to a device (locally or remotely) using a
    placement algorithm. This may make decisions based on collected
    statistics from the workers in the system (e.g., memory usage,
    bandwidth consumption, etc.)

    * inserting intermediate nodes and edges to support cross-device
    and cross-process data flows and resource management.

    * issuing commands to workers to execute the subgraphs associated
    with those workers.

    Typically, a client carries out an iterative computation
    (e.g. training) by invoking RPCs against the master in a
    client-side loop. The client first creates a client session that
    connects to a particular master (using gRPC for example). The
    master creates a corresponding master session that is hosted on
    the master and caches state between the client's invocations.

    After the session is established, the master returns an opaque
    handle to the client that can be used to associate the client and
    master sessions.

    The client may send an initial graph to the master in the
    CreateSession call, and add nodes to the graph using ExtendSession.

    The most frequent operation a master is "RunStep", which implements
    the `Session::Run()` API. It supports feeding in arguments,
    executing a dataflow computation, and fetching arguments.

    Finally, when the client no longer needs the session, it should
    close the session by invoking CloseSession, which allows the master
    to reclaim resources associated with the session. The master may
    implement a garbage collection scheme that closes sessions that
    have been inactive for some time.

    For example, the following pseudo-code illustrates how a client
    interacts with a master:

    stub = NewStub("/job:mnist/replica:0/task:0")
    {handle} = stub->CreateSession({graph_def})
    do {
    stub->RunStep({handle, {feeds}, {fetches}})
    // The client can evaluate a predicate locally, based on the
    // result of `fetches`, to determine whether to terminate. For
    // example, it might fetch the loss and evaluate whether it is less
    // than some threshold.
    } while (!should_stop({fetches}));
    stub->CloseSession({handle})

    //////////////////////////////////////////////////////////////////////////////

    """

    def __init__(self, channel):
      """Constructor.

      Args:
        channel: A grpc.Channel.
      """
      self.CreateSession = channel.unary_unary(
          '/tensorflow.grpc.MasterService/CreateSession',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionResponse.FromString,
          )
      self.ExtendSession = channel.unary_unary(
          '/tensorflow.grpc.MasterService/ExtendSession',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionResponse.FromString,
          )
      self.PartialRunSetup = channel.unary_unary(
          '/tensorflow.grpc.MasterService/PartialRunSetup',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupResponse.FromString,
          )
      self.RunStep = channel.unary_unary(
          '/tensorflow.grpc.MasterService/RunStep',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepResponse.FromString,
          )
      self.CloseSession = channel.unary_unary(
          '/tensorflow.grpc.MasterService/CloseSession',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionResponse.FromString,
          )
      self.ListDevices = channel.unary_unary(
          '/tensorflow.grpc.MasterService/ListDevices',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesResponse.FromString,
          )
      self.Reset = channel.unary_unary(
          '/tensorflow.grpc.MasterService/Reset',
          request_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetRequest.SerializeToString,
          response_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetResponse.FromString,
          )


  class MasterServiceServicer(object):
    """//////////////////////////////////////////////////////////////////////////////

    MasterService defines a TensorFlow service with which a client can
    interact to execute a distributed TensorFlow computation.

    A master service keeps track of multiple "master sessions". Each
    session encapsulates a computation graph and its associated state,
    and typically corresponds to a single "client session" (e.g. a
    `tensorflow::Session` instance).

    A session is responsible for the following:
    * assigning each node to a device (locally or remotely) using a
    placement algorithm. This may make decisions based on collected
    statistics from the workers in the system (e.g., memory usage,
    bandwidth consumption, etc.)

    * inserting intermediate nodes and edges to support cross-device
    and cross-process data flows and resource management.

    * issuing commands to workers to execute the subgraphs associated
    with those workers.

    Typically, a client carries out an iterative computation
    (e.g. training) by invoking RPCs against the master in a
    client-side loop. The client first creates a client session that
    connects to a particular master (using gRPC for example). The
    master creates a corresponding master session that is hosted on
    the master and caches state between the client's invocations.

    After the session is established, the master returns an opaque
    handle to the client that can be used to associate the client and
    master sessions.

    The client may send an initial graph to the master in the
    CreateSession call, and add nodes to the graph using ExtendSession.

    The most frequent operation a master is "RunStep", which implements
    the `Session::Run()` API. It supports feeding in arguments,
    executing a dataflow computation, and fetching arguments.

    Finally, when the client no longer needs the session, it should
    close the session by invoking CloseSession, which allows the master
    to reclaim resources associated with the session. The master may
    implement a garbage collection scheme that closes sessions that
    have been inactive for some time.

    For example, the following pseudo-code illustrates how a client
    interacts with a master:

    stub = NewStub("/job:mnist/replica:0/task:0")
    {handle} = stub->CreateSession({graph_def})
    do {
    stub->RunStep({handle, {feeds}, {fetches}})
    // The client can evaluate a predicate locally, based on the
    // result of `fetches`, to determine whether to terminate. For
    // example, it might fetch the loss and evaluate whether it is less
    // than some threshold.
    } while (!should_stop({fetches}));
    stub->CloseSession({handle})

    //////////////////////////////////////////////////////////////////////////////

    """

    def CreateSession(self, request, context):
      """Creates a session.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def ExtendSession(self, request, context):
      """Extends a session.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def PartialRunSetup(self, request, context):
      """Prepares future partial run calls.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def RunStep(self, request, context):
      """Drives the graph computation.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def CloseSession(self, request, context):
      """Closes a session.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def ListDevices(self, request, context):
      """List the devices usable by the master.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')

    def Reset(self, request, context):
      """Close and abandon all existing sessions.  Ongoing computations
      will no longer affect fresh ones via the resources in containers listed in
      the ResetRequest.  See ResetRequest for more details.
      """
      context.set_code(grpc.StatusCode.UNIMPLEMENTED)
      context.set_details('Method not implemented!')
      raise NotImplementedError('Method not implemented!')


  def add_MasterServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
        'CreateSession': grpc.unary_unary_rpc_method_handler(
            servicer.CreateSession,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionResponse.SerializeToString,
        ),
        'ExtendSession': grpc.unary_unary_rpc_method_handler(
            servicer.ExtendSession,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionResponse.SerializeToString,
        ),
        'PartialRunSetup': grpc.unary_unary_rpc_method_handler(
            servicer.PartialRunSetup,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupResponse.SerializeToString,
        ),
        'RunStep': grpc.unary_unary_rpc_method_handler(
            servicer.RunStep,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepResponse.SerializeToString,
        ),
        'CloseSession': grpc.unary_unary_rpc_method_handler(
            servicer.CloseSession,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionResponse.SerializeToString,
        ),
        'ListDevices': grpc.unary_unary_rpc_method_handler(
            servicer.ListDevices,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesResponse.SerializeToString,
        ),
        'Reset': grpc.unary_unary_rpc_method_handler(
            servicer.Reset,
            request_deserializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetRequest.FromString,
            response_serializer=tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetResponse.SerializeToString,
        ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
        'tensorflow.grpc.MasterService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


  class BetaMasterServiceServicer(object):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This class was generated
    only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0."""
    """//////////////////////////////////////////////////////////////////////////////

    MasterService defines a TensorFlow service with which a client can
    interact to execute a distributed TensorFlow computation.

    A master service keeps track of multiple "master sessions". Each
    session encapsulates a computation graph and its associated state,
    and typically corresponds to a single "client session" (e.g. a
    `tensorflow::Session` instance).

    A session is responsible for the following:
    * assigning each node to a device (locally or remotely) using a
    placement algorithm. This may make decisions based on collected
    statistics from the workers in the system (e.g., memory usage,
    bandwidth consumption, etc.)

    * inserting intermediate nodes and edges to support cross-device
    and cross-process data flows and resource management.

    * issuing commands to workers to execute the subgraphs associated
    with those workers.

    Typically, a client carries out an iterative computation
    (e.g. training) by invoking RPCs against the master in a
    client-side loop. The client first creates a client session that
    connects to a particular master (using gRPC for example). The
    master creates a corresponding master session that is hosted on
    the master and caches state between the client's invocations.

    After the session is established, the master returns an opaque
    handle to the client that can be used to associate the client and
    master sessions.

    The client may send an initial graph to the master in the
    CreateSession call, and add nodes to the graph using ExtendSession.

    The most frequent operation a master is "RunStep", which implements
    the `Session::Run()` API. It supports feeding in arguments,
    executing a dataflow computation, and fetching arguments.

    Finally, when the client no longer needs the session, it should
    close the session by invoking CloseSession, which allows the master
    to reclaim resources associated with the session. The master may
    implement a garbage collection scheme that closes sessions that
    have been inactive for some time.

    For example, the following pseudo-code illustrates how a client
    interacts with a master:

    stub = NewStub("/job:mnist/replica:0/task:0")
    {handle} = stub->CreateSession({graph_def})
    do {
    stub->RunStep({handle, {feeds}, {fetches}})
    // The client can evaluate a predicate locally, based on the
    // result of `fetches`, to determine whether to terminate. For
    // example, it might fetch the loss and evaluate whether it is less
    // than some threshold.
    } while (!should_stop({fetches}));
    stub->CloseSession({handle})

    //////////////////////////////////////////////////////////////////////////////

    """
    def CreateSession(self, request, context):
      """Creates a session.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def ExtendSession(self, request, context):
      """Extends a session.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def PartialRunSetup(self, request, context):
      """Prepares future partial run calls.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def RunStep(self, request, context):
      """Drives the graph computation.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def CloseSession(self, request, context):
      """Closes a session.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def ListDevices(self, request, context):
      """List the devices usable by the master.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)
    def Reset(self, request, context):
      """Close and abandon all existing sessions.  Ongoing computations
      will no longer affect fresh ones via the resources in containers listed in
      the ResetRequest.  See ResetRequest for more details.
      """
      context.code(beta_interfaces.StatusCode.UNIMPLEMENTED)


  class BetaMasterServiceStub(object):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This class was generated
    only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0."""
    """//////////////////////////////////////////////////////////////////////////////

    MasterService defines a TensorFlow service with which a client can
    interact to execute a distributed TensorFlow computation.

    A master service keeps track of multiple "master sessions". Each
    session encapsulates a computation graph and its associated state,
    and typically corresponds to a single "client session" (e.g. a
    `tensorflow::Session` instance).

    A session is responsible for the following:
    * assigning each node to a device (locally or remotely) using a
    placement algorithm. This may make decisions based on collected
    statistics from the workers in the system (e.g., memory usage,
    bandwidth consumption, etc.)

    * inserting intermediate nodes and edges to support cross-device
    and cross-process data flows and resource management.

    * issuing commands to workers to execute the subgraphs associated
    with those workers.

    Typically, a client carries out an iterative computation
    (e.g. training) by invoking RPCs against the master in a
    client-side loop. The client first creates a client session that
    connects to a particular master (using gRPC for example). The
    master creates a corresponding master session that is hosted on
    the master and caches state between the client's invocations.

    After the session is established, the master returns an opaque
    handle to the client that can be used to associate the client and
    master sessions.

    The client may send an initial graph to the master in the
    CreateSession call, and add nodes to the graph using ExtendSession.

    The most frequent operation a master is "RunStep", which implements
    the `Session::Run()` API. It supports feeding in arguments,
    executing a dataflow computation, and fetching arguments.

    Finally, when the client no longer needs the session, it should
    close the session by invoking CloseSession, which allows the master
    to reclaim resources associated with the session. The master may
    implement a garbage collection scheme that closes sessions that
    have been inactive for some time.

    For example, the following pseudo-code illustrates how a client
    interacts with a master:

    stub = NewStub("/job:mnist/replica:0/task:0")
    {handle} = stub->CreateSession({graph_def})
    do {
    stub->RunStep({handle, {feeds}, {fetches}})
    // The client can evaluate a predicate locally, based on the
    // result of `fetches`, to determine whether to terminate. For
    // example, it might fetch the loss and evaluate whether it is less
    // than some threshold.
    } while (!should_stop({fetches}));
    stub->CloseSession({handle})

    //////////////////////////////////////////////////////////////////////////////

    """
    def CreateSession(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Creates a session.
      """
      raise NotImplementedError()
    CreateSession.future = None
    def ExtendSession(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Extends a session.
      """
      raise NotImplementedError()
    ExtendSession.future = None
    def PartialRunSetup(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Prepares future partial run calls.
      """
      raise NotImplementedError()
    PartialRunSetup.future = None
    def RunStep(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Drives the graph computation.
      """
      raise NotImplementedError()
    RunStep.future = None
    def CloseSession(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Closes a session.
      """
      raise NotImplementedError()
    CloseSession.future = None
    def ListDevices(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """List the devices usable by the master.
      """
      raise NotImplementedError()
    ListDevices.future = None
    def Reset(self, request, timeout, metadata=None, with_call=False, protocol_options=None):
      """Close and abandon all existing sessions.  Ongoing computations
      will no longer affect fresh ones via the resources in containers listed in
      the ResetRequest.  See ResetRequest for more details.
      """
      raise NotImplementedError()
    Reset.future = None


  def beta_create_MasterService_server(servicer, pool=None, pool_size=None, default_timeout=None, maximum_timeout=None):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This function was
    generated only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0"""
    request_deserializers = {
      ('tensorflow.grpc.MasterService', 'CloseSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionRequest.FromString,
      ('tensorflow.grpc.MasterService', 'CreateSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionRequest.FromString,
      ('tensorflow.grpc.MasterService', 'ExtendSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionRequest.FromString,
      ('tensorflow.grpc.MasterService', 'ListDevices'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesRequest.FromString,
      ('tensorflow.grpc.MasterService', 'PartialRunSetup'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupRequest.FromString,
      ('tensorflow.grpc.MasterService', 'Reset'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetRequest.FromString,
      ('tensorflow.grpc.MasterService', 'RunStep'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepRequest.FromString,
    }
    response_serializers = {
      ('tensorflow.grpc.MasterService', 'CloseSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'CreateSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'ExtendSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'ListDevices'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'PartialRunSetup'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'Reset'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetResponse.SerializeToString,
      ('tensorflow.grpc.MasterService', 'RunStep'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepResponse.SerializeToString,
    }
    method_implementations = {
      ('tensorflow.grpc.MasterService', 'CloseSession'): face_utilities.unary_unary_inline(servicer.CloseSession),
      ('tensorflow.grpc.MasterService', 'CreateSession'): face_utilities.unary_unary_inline(servicer.CreateSession),
      ('tensorflow.grpc.MasterService', 'ExtendSession'): face_utilities.unary_unary_inline(servicer.ExtendSession),
      ('tensorflow.grpc.MasterService', 'ListDevices'): face_utilities.unary_unary_inline(servicer.ListDevices),
      ('tensorflow.grpc.MasterService', 'PartialRunSetup'): face_utilities.unary_unary_inline(servicer.PartialRunSetup),
      ('tensorflow.grpc.MasterService', 'Reset'): face_utilities.unary_unary_inline(servicer.Reset),
      ('tensorflow.grpc.MasterService', 'RunStep'): face_utilities.unary_unary_inline(servicer.RunStep),
    }
    server_options = beta_implementations.server_options(request_deserializers=request_deserializers, response_serializers=response_serializers, thread_pool=pool, thread_pool_size=pool_size, default_timeout=default_timeout, maximum_timeout=maximum_timeout)
    return beta_implementations.server(method_implementations, options=server_options)


  def beta_create_MasterService_stub(channel, host=None, metadata_transformer=None, pool=None, pool_size=None):
    """The Beta API is deprecated for 0.15.0 and later.

    It is recommended to use the GA API (classes and functions in this
    file not marked beta) for all further purposes. This function was
    generated only to ease transition from grpcio<0.15.0 to grpcio>=0.15.0"""
    request_serializers = {
      ('tensorflow.grpc.MasterService', 'CloseSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'CreateSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'ExtendSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'ListDevices'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'PartialRunSetup'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'Reset'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetRequest.SerializeToString,
      ('tensorflow.grpc.MasterService', 'RunStep'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepRequest.SerializeToString,
    }
    response_deserializers = {
      ('tensorflow.grpc.MasterService', 'CloseSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CloseSessionResponse.FromString,
      ('tensorflow.grpc.MasterService', 'CreateSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.CreateSessionResponse.FromString,
      ('tensorflow.grpc.MasterService', 'ExtendSession'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ExtendSessionResponse.FromString,
      ('tensorflow.grpc.MasterService', 'ListDevices'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ListDevicesResponse.FromString,
      ('tensorflow.grpc.MasterService', 'PartialRunSetup'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.PartialRunSetupResponse.FromString,
      ('tensorflow.grpc.MasterService', 'Reset'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.ResetResponse.FromString,
      ('tensorflow.grpc.MasterService', 'RunStep'): tensorflow_dot_core_dot_protobuf_dot_master__pb2.RunStepResponse.FromString,
    }
    cardinalities = {
      'CloseSession': cardinality.Cardinality.UNARY_UNARY,
      'CreateSession': cardinality.Cardinality.UNARY_UNARY,
      'ExtendSession': cardinality.Cardinality.UNARY_UNARY,
      'ListDevices': cardinality.Cardinality.UNARY_UNARY,
      'PartialRunSetup': cardinality.Cardinality.UNARY_UNARY,
      'Reset': cardinality.Cardinality.UNARY_UNARY,
      'RunStep': cardinality.Cardinality.UNARY_UNARY,
    }
    stub_options = beta_implementations.stub_options(host=host, metadata_transformer=metadata_transformer, request_serializers=request_serializers, response_deserializers=response_deserializers, thread_pool=pool, thread_pool_size=pool_size)
    return beta_implementations.dynamic_stub(channel, 'tensorflow.grpc.MasterService', cardinalities, options=stub_options)
except ImportError:
  pass
# @@protoc_insertion_point(module_scope)
